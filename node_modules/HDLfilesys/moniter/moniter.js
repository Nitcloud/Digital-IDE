"use strict";

const fs = require("fs");
const fspath = require("path");
const vscode = require("vscode");
const chokidar = require("chokidar");
const dir = require("../operation/dirs");
const prjs = require("../operation/prjs");
const files = require("../operation/files");
/*
工程监测函数，Q: 是否需要分开监测？目前是全局监测，若是分开监测就需要多个chokidar.watch对象，是否会对系统性能造成影响增加CPU压力？
path: 全局监测路径
opeParam: 工程执行参数
indexer: 工程检索类
outputChannel: 输出log的vscode类
callback: 回调函数，目前用于触发tree view的更新
*/
function monitor(path, opeParam, indexer, outputChannel, callback) {
    const watcher = chokidar.watch(`${path}/**/*{log,json,v,V,sv,SV,vh,vl,vhd,vhdl,vho,vht}`, {
        persistent: true,
        usePolling: false,
        ignoreInitial: true,
        // awaitWriteFinish: {   // ms
        //     stabilityThreshold: 2000,
        //     pollInterval: 100
        // }
    });
    let processHDL = new prjs.processHDLFile(opeParam, watcher);
    if (opeParam.propertyPath != "") {
        processPropertyFile(opeParam, indexer, processHDL);
    }
    // 添加监听事件
    watcher.on('add', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${path} has been added`);
        onCreate(path, indexer, processHDL, callback, opeParam);
    });
    watcher.on('change', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${(path)} has been changed`);
        onChange(path, indexer, processHDL, callback, opeParam, outputChannel);
    });
    watcher.on('unlink', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${path} has been removed`);
        onDelete(path, indexer, processHDL, callback);
    });

    return watcher;
    // 监听新的文件.
    // watcher.add(['new-file-2', 'new-file-3', '**/other-file*']);
    // 禁止监听指定的文件
    // watcher.unwatch('new-file*');
    // 其他可能用到的事件
    // watcher
    // .on('addDir', path => log(`Directory ${path} has been added`))
    // .on('unlinkDir', path => log(`Directory ${path} has been removed`))
    // .on('error', error => log(`Watcher error: ${error}`))
    // .on('ready', () => log('Initial scan complete. Ready for changes'))
    // .on('raw', (event, path, details) => {
    // log('Raw event info:', event, path, details);
    // });
}
exports.monitor = monitor;

async function onCreate(path, indexer, processHDL, callback, opeParam) {
    try {
        if (path.indexOf("property.json") != -1) {
            processPropertyFile(opeParam, indexer, processHDL);
        } else {
            await indexer.processFile(vscode.Uri.file(path), indexer.HDLparam);
            indexer.refreshInstModulePath(indexer.HDLparam);
            processHDL.addLibFiles([path]);
        }
        callback();
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

async function onChange(path, indexer, processHDL, callback, opeParam, outputChannel) {
    try {
        xExecShowLog(path, outputChannel);
        if (path.indexOf("property.json") != -1) {
            processPropertyFile(opeParam, indexer, processHDL);
            callback();
        } else {
            indexer.removeCurrentFileParam(path);
            indexer.symbols.delete(path);
            await indexer.processFile(vscode.Uri.file(path), indexer.HDLparam);
            indexer.refreshInstModulePath(indexer.HDLparam);
            callback();
        }
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

async function onDelete(path, indexer, processHDL, callback) {
    try {
        if (path.indexOf("property.json") != -1) {
            opeParam.propertyPath = "";
        } else {
            indexer.removeCurrentFileParam(path);
            indexer.symbols.delete(path);
            indexer.refreshInstModulePath(indexer.HDLparam);
            processHDL.delLibFiles([path]);
        }
        callback();
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

async function processPropertyFile(opeParam, indexer, processHDL) {
    console.time('libtimer');
    prjs.getPropertyInfo(opeParam);   // 刷新工程信息
    prjs.refreshPrjFolder(opeParam);  // 更新工程结构
    processHDL.getLibFiles();         // 获取lib参数
    let libFiles = processHDL.processLibFiles(); // 处理lib参数
    // 从HDLparam和HDLsymbol中删除用不到的lib文件
    for (let i = 0; i < libFiles.del.length; i++) {
        const elementPath = libFiles.del[i];
        indexer.removeCurrentFileParam(elementPath);
        indexer.symbols.delete(elementPath);
    }
    // 向HDLparam和HDLsymbol中添加新lib文件
    await Promise.all(libFiles.add.map((elementPath) => {
        return indexer.processFile(vscode.Uri.file(elementPath), indexer.HDLparam);
    }));
    // 刷新路径
    if (libFiles.del.length || libFiles.add.length) {
        indexer.refreshInstModulePath(indexer.HDLparam);
    }
    console.log(indexer.HDLparam);
    console.log(indexer.symbols);
    console.timeEnd('libtimer');
}
exports.processPropertyFile = processPropertyFile;

function xExecShowLog(path, outputChannel) {
    let logPathList = ["runme.log", "xvlog.log", "elaborate.log"];
    let fileName = fspath.basename(path);
    if (logPathList.indexOf(fileName) != -1) {
        let log = "";
        let islinefinish = true;
        let content = fs.readFileSync(path, "utf-8");
        let lines = content.split('\n');
        if (lines[lines.length - 2].indexOf("INFO: [Common 17-206] Exiting Vivado") != -1) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.indexOf("INFO:") != -1 || line.indexOf("WARNING:") != -1) {
                    islinefinish = true;
                } else if (line.indexOf("ERROR:") != -1) {
                    islinefinish = false;
                    log = log + line.replace("ERROR:", "[ERROR] :") + "\n";
                } else if (line.indexOf("CRITICAL WARNING:") != -1) {
                    islinefinish = false;
                    log = log + line.replace("CRITICAL WARNING:", "[CRITICAL WARNING] :") + "\n";
                }
                if (!islinefinish) {
                    log = log + line + "\n";
                }
            }
            if (log != "") {
                outputChannel.show(true);
                outputChannel.appendLine(log);
            }
        }
    }
}